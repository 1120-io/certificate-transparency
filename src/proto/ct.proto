syntax = "proto2";

package ct;

message DigitallySigned {
  enum HashAlgorithm {
    NONE = 0;
    MD5 = 1;
    SHA1 = 2;
    SHA224 = 3;
    SHA256 = 4;
    SHA384 = 5;
    SHA512 = 6;
  }

  enum SignatureAlgorithm {
    ANONYMOUS = 0;
    RSA = 1;
    DSA = 2;
    ECDSA = 3;
  }

  required HashAlgorithm hash_algorithm = 1 [ default = NONE ];
  required SignatureAlgorithm sig_algorithm = 2 [ default = ANONYMOUS ];
  optional bytes signature = 3;
}

message CertificateEntry {
  // Maps 1-1 to ct::CertificateEntryType
  enum Type {
    X509_ENTRY = 0;
    PRECERT_ENTRY = 1;
  }

  required Type type = 1 [ default = X509_ENTRY ];
  // In the case of a regular entry, the leaf certificate.
  // In the case of a pre-cert entry, the tbs part of the leaf certificate.
  // Signed.
  optional bytes leaf_certificate = 2;

  // In the case of a regular entry, a chain from the leaf
  // to a trusted root (excluding leaf and root).
  // In the case of a pre-cert entry, this contains the full original
  // pre-cert chain, as submitted by the CA.
  // Unsigned, kept as evidence.
  repeated bytes intermediates = 3;
}

// TODO(ekasper): Consider moving the CertificateEntry out of this
// message to LoggedCertificate, to better match the I-D.
message SignedCertificateTimestamp {
  // UTC time in milliseconds, since January 1, 1970, 00:00.
  optional uint64 timestamp = 1;
  optional CertificateEntry entry = 2;
  optional DigitallySigned signature = 3;
}

message LoggedCertificate {
  required SignedCertificateTimestamp sct = 1;
  required bytes certificate_sha256_hash = 2;
  optional uint64 sequence_number = 3;
}

message SignedTreeHead {
  optional uint64 timestamp = 1;
  optional uint64 tree_size = 2;
  optional bytes root_hash = 3;
  optional DigitallySigned signature = 4;
}

message MerkleAuditProof {
  optional uint64 tree_size = 1;
  optional uint64 timestamp = 2;
  optional uint64 leaf_index = 3;
  repeated bytes path_node = 4;
  optional DigitallySigned tree_head_signature = 5;
}

// Server-client messages
message ClientMessage {
  enum ClientCommand {
    // Upload a certificate bundle, and retrieve
    // a submission token, or an audit proof.
    SUBMIT_BUNDLE = 1;
    SUBMIT_CA_BUNDLE = 2;
  }
  required ClientCommand command = 2;
  optional bytes submission_data = 3;
}

message ServerError {
  enum ErrorCode {
    BAD_VERSION = 0;
    UNSUPPORTED_FORMAT = 1;
    INVALID_MESSAGE = 2;
    UNSUPPORTED_COMMAND = 3;
    REJECTED = 4;
  }
  required ErrorCode code = 1;
  optional string error_message = 2;
}

message ServerMessage {
  // The server's response codes.
  enum ServerResponse {
    ERROR = 0;
    SIGNED_CERTIFICATE_TIMESTAMP = 1;
    LOGGED = 2;
  }
  required ServerResponse response = 1;
  // Normally only one of those will be set.
  optional ServerError error = 2;
  optional SignedCertificateTimestamp sct = 3;
}
